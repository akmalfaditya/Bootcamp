using System.ComponentModel.DataAnnotations;

namespace ProductCatalogAPI.Models
{
    /// <summary>
    /// Represents a product in our catalog system.
    /// This is our main business entity that will be exposed through the Web API.
    /// Think of this as the core data structure that different clients (web, mobile, IoT) will interact with.
    /// </summary>
    public class Product
    {
        /// <summary>
        /// Primary key for the product. EF Core will automatically recognize this as the primary key.
        /// In a real-world scenario, this would be auto-generated by the database.
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Product name with validation to ensure data integrity.
        /// We're using data annotations to validate input - this is crucial for APIs
        /// because we can't trust data coming from external clients.
        /// </summary>
        [Required(ErrorMessage = "Product name is required")]
        [StringLength(100, MinimumLength = 3, ErrorMessage = "Product name must be between 3 and 100 characters")]
        public string Name { get; set; } = string.Empty;

        /// <summary>
        /// Detailed description of the product.
        /// Notice this is optional (nullable) - not all products might have descriptions.
        /// </summary>
        [StringLength(500, ErrorMessage = "Description cannot exceed 500 characters")]
        public string? Description { get; set; }

        /// <summary>
        /// Product price with validation to ensure it's within reasonable bounds.
        /// Using decimal for currency to avoid floating-point precision issues.
        /// </summary>
        [Required(ErrorMessage = "Price is required")]
        [Range(0.01, 999999.99, ErrorMessage = "Price must be between $0.01 and $999,999.99")]
        public decimal Price { get; set; }

        /// <summary>
        /// Current stock quantity. This would be crucial for inventory management.
        /// Notice we're constraining it to non-negative values.
        /// </summary>
        [Required(ErrorMessage = "Stock quantity is required")]
        [Range(0, int.MaxValue, ErrorMessage = "Stock quantity cannot be negative")]
        public int StockQuantity { get; set; }

        /// <summary>
        /// Product category foreign key.
        /// This establishes a relationship between Product and Category entities.
        /// </summary>
        public int CategoryId { get; set; }

        /// <summary>
        /// Navigation property to the related category.
        /// This allows EF Core to load related data and establishes the relationship in our domain model.
        /// The virtual keyword enables lazy loading (though we'll use explicit loading in our examples).
        /// </summary>
        public virtual Category Category { get; set; } = null!;

        /// <summary>
        /// When the product was created. Useful for tracking and auditing.
        /// We'll set this automatically in our service layer.
        /// </summary>
        public DateTime CreatedDate { get; set; }

        /// <summary>
        /// Last modification date. Essential for tracking changes and caching strategies.
        /// </summary>
        public DateTime LastModifiedDate { get; set; }

        /// <summary>
        /// Soft delete flag. Instead of actually deleting products (which could break historical data),
        /// we mark them as inactive. This is a common pattern in production systems.
        /// </summary>
        public bool IsActive { get; set; } = true;
    }
}
